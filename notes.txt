If the target is to make a user-friendly Windows API monitor, there are tons of ready-to-use tools lying around:
	Huorong Sword: https://www.huorong.cn/
	API Monitor: https://www.rohitab.com/apimonitor
	Process Monitor from Sysinternals: https://docs.microsoft.com/en-us/sysinternals/downloads/procmon
So my version of PEDoll will NOT focus on pretty-printing Windows APIs, but on better interoperability with internal procedures

----------

Hook Events:
	Before...
		return context-related data
		Approve/Reject(req. SPOffset & AX)/Terminate/Prompt
	After...
		return context-related data
		Continue/Terminate/Prompt

*IMPORTANT*: The "binary hooker" PeDoll implements ALSO only work on procedures
		And only support 1 instance

registers to preserve:
	x86
		pushad/popad
		eax, ecx, edx, ebx, esp, ebp, esi, edi
	x64
		rax, rcx, rdx, rbx, rbp, rsp, rdi, rsi, r8, r9
	(?) FP registers (sub ebp, 16; movdqu xmmword ptr[ebp], xmm0)
		xmm0, xmm1, xmm2, xmm3

calling conventions:
	x86
		cdecl/stdcall (stack)
		fastcall (rcx, rdx, stack)
	x64
		msvc (rcx, rdx, r8, r9, stack)
		gcc (rdi, rsi, rdx, rcx, r8, r9, stack)

----------

How the commands in original PeDoll are implemented:

- Monitor commands
* doll
	- "iti": IAT rewriting
		- Creating a new execuable with PE.dll in the IAT
	- "bi": OEP rewriting
		- Creating a new execuable with OEP redirected to the LoadLibrary() shellcode
	- "di": Remote thread (recommended for attaching)
		- CreateRemoteThread() with LoadLibrary() as OEP
	- "db": OEP rewriting approach I (recommended for launching)
		- CreateProcess(CREATE_SUSPENDED), then redirect OEP to LoadLibrary() shellcode
	- "ac": OEP rewriting approach II
		- Basically the same as "db"
* shell
	- CreateProcess()
* enumprocess
	- CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS)
* ls
	- FindFirstFile()
* kill
	- Get process handle by CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS), then TerminateProcess()

- Doll commands
* hook
	- A big switch() comparing against a known API list
	- See DLLMain_cn.cpp!HookFunctionCommand
* unhook
	- rt
* terminate
	- exit(0)
* run
	- Did nothing but reply a ACK packet
* esp
	- ACK packet with *current* esp value
	- Is of any use?
* readMemory
	- ReadProcessMemory() with GetCurrentProcess()
* binary
	- Activate the spare APIHooker
	- Locate mechanism: Search binary from GetModuleHandle(NULL) to (0x07ffffff - size) step 1
* unbinary
	- rt

----------

lexer replacement(?): https://github.com/skeeto/optparse
https://github.com/xamarin/XamarinComponents/tree/master/XPlat/Mono.Options

https://github.com/OmarAflak/Asynchronous-Socket-Class-C-Windows/blob/master/src/SocketServer.cpp
https://docs.microsoft.com/zh-cn/dotnet/api/system.net.sockets.tcplistener?view=netframework-4.8
https://stackoverflow.com/a/16300698

----------

ARGHHHH C# Interop

Recv packet routine:
	receive sizeof(UInt32) bytes (block at here)
	convert this byte[] into UInt32 as $size (UInt32 System.BitConverter.ToUInt32(byte[] value, int startIndex))
	receive ($size - sizeof(UInt32)) bytes
	combine two byte[]s as $buffer
	Puppet.Util.Deserialize<PACKET>(buffer) as $packet
	OnRecv(packet, buffer)
	(In OnRecv) Puppet.Util.Deserialize(<PACKET_*>|String|Binary)(buffer) as it wish
		Still need a PuppetExpect<>

Send packet routine (not STRING or BINARY):
	new Puppet.PACKET_*() as $packet
	Puppet.Util.Serialize<PACKET_*> as $buffer
	send buffer

Send packet routine (STRING or BINARY):
	Puppet.Util.Serialize(String|Binary)() as $buffer
	send buffer

----------

C# has "lock(obj) { ...}"
a "nothing-but-a-lock" object: "object theLock = new object();"

Shift-Enter inputs newline in the Visual Studio resource editor

Set Form.Localizable to True
Change Language to write in values

----------

Threads/Tasks of PEDollController:

(Main thread):
	initialize
	start CmdEngine and GUI
	wait until CmdEngine ends
	finalize

CmdEngine:
	initialize readline providers
	wait for a line
	OnCommand(cmd, isGUI)
		may start Listener or stop CmdEngine
	loop forever

Listener: // Listeners?
	bind to TCP port
	wait for incoming connection
	create & start a new Client
	loop forever

Client:
	wait for incoming packet
	OnRecv(packet, buffer)
		may stop current Client (put in a DEAD status, not removing from the list)
	loop forever

GUI:
	show FSplash
		initialize GUI-related things
	show FMain
	wait until FMain closes

