If the target is to make a user-friendly Windows API monitor, there are tons of ready-to-use tools lying around:
	Huorong Sword: https://www.huorong.cn/
	API Monitor: https://www.rohitab.com/apimonitor
	Process Monitor from Sysinternals: https://docs.microsoft.com/en-us/sysinternals/downloads/procmon
So my version of PEDoll will NOT focus on pretty-printing Windows APIs, but on better interoperability with internal procedures

----------

lexer replacement(?): https://github.com/skeeto/optparse
https://github.com/xamarin/XamarinComponents/tree/master/XPlat/Mono.Options

https://github.com/OmarAflak/Asynchronous-Socket-Class-C-Windows/blob/master/src/SocketServer.cpp
https://docs.microsoft.com/zh-cn/dotnet/api/system.net.sockets.tcplistener?view=netframework-4.8

MAKE USE OF Win32 API multi-threading functions!
	InitializeCriticalSection / TryEnterCriticalSection / EnterCriticalSection / LeaveCriticalSection / DeleteCriticalSection
	CreateEvent / SetEvent / ResetEvent / WaitForSingleObject (/ WaitForMultipleObjects) / CloseHandle

----------

Hook Events:
	Before...
		return context-related data
		Approve/Reject(req. SPOffset & AX)/Terminate/Prompt
	After...
		return context-related data
		Continue/Terminate/Prompt

*IMPORTANT*: The "binary hooker" PeDoll implements ALSO only work on procedures
		And only support 1 instance

registers to preserve:
	x86
		pushad/popad
		eax, ecx, edx, ebx, esp, ebp, esi, edi
	x64
		rax, rcx, rdx, rbx, rbp, rsp, rdi, rsi, r8, r9
	(?) FP registers (sub ebp, 16; movdqu xmmword ptr[ebp], xmm0)
		xmm0, xmm1, xmm2, xmm3

calling conventions:
	x86
		cdecl/stdcall (stack)
		fastcall (rcx, rdx, stack)
	x64
		msvc (rcx, rdx, r8, r9, stack)
		gcc (rdi, rsi, rdx, rcx, r8, r9, stack)

----------
ALL operations (requesting for data, verdict results, etc) are done on the Controller side
	all a Doll have to do is to wait for Controller's request/reply

Q: Under this "centralized" architechure, How does libDoll know where the server is?
A: The Monitor/Spawner will create a static channel for a temp one-way communication (shared memory?)
UPDATE: Even can do with DetourCopyPayloadToProcess() + DetourEnumerateModules() + DetourFindPayload()
	DetourEnumerateModules() because the payload is in a injected dummy module
https://github.com/microsoft/Detours/wiki/DetourCopyPayloadToProcess

----------

How the commands in original PeDoll are implemented:

- Monitor commands
* doll
	- "iti": IAT rewriting
		- Creating a new execuable with PE.dll in the IAT
	- "bi": OEP rewriting
		- Creating a new execuable with OEP redirected to the LoadLibrary() shellcode
	- "di": Remote thread (recommended for attaching)
		- CreateRemoteThread() with LoadLibrary() as OEP
	- "db": OEP rewriting approach I (recommended for launching)
		- CreateProcess(CREATE_SUSPENDED), then redirect OEP to LoadLibrary() shellcode
	- "ac": OEP rewriting approach II
		- Basically the same as "db"
* shell
	- CreateProcess()
* enumprocess
	- CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS)
* ls
	- FindFirstFile()
* kill
	- Get process handle by CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS), then TerminateProcess()

- Doll commands
* hook
	- A big switch() comparing against a known API list
	- See DLLMain_cn.cpp!HookFunctionCommand
* unhook
	- rt
* terminate
	- exit(0)
* run
	- Did nothing but reply a ACK packet
* esp
	- ACK packet with *current* esp value
	- Is of any use?
* readMemory
	- ReadProcessMemory() with GetCurrentProcess()
* binary
	- Activate the spare APIHooker
	- Locate mechanism: Search binary from GetModuleHandle(NULL) to (0x07ffffff - size) step 1
* unbinary
	- rt

NOTE: From https://docs.microsoft.com/en-us/windows-hardware/drivers/gettingstarted/virtual-address-spaces :
> For a 32-bit process, the virtual address space is usually the 2-gigabyte range 0x00000000 through 0x7FFFFFFF. For a 64-bit process, the virtual address space is the 8-terabyte range 0x000'00000000 through 0x7FF'FFFFFFFF.
> In 32-bit Windows, the total available virtual address space is 2^32 bytes (4 gigabytes). Usually the lower 2 gigabytes are used for user space, and the upper 2 gigabytes are used for system space.
> In 64-bit Windows, the theoretical amount of virtual address space is 2^64 bytes (16 exabytes), but only a small portion of the 16-exabyte range is actually used. The 8-terabyte range from 0x000'00000000 through 0x7FF'FFFFFFFF is used for user space, and portions of the 248-terabyte range from 0xFFFF0800'00000000 through 0xFFFFFFFF'FFFFFFFF are used for system space.
i.e. Searching directly to the end is no longer an option. So how to do?

(???) Even CheatEngine Uses per-byte method
http://www.ruanyifeng.com/blog/2013/05/boyer-moore_string_search_algorithm.html
https://social.msdn.microsoft.com/forums/en-US/65c1ab16-2690-4117-9d3c-aa55f5cbc453/searching-binary-data#778f3f7e-17f3-48dc-8a47-c1678cfc33c8

----------

Q: How does the created/attached process know where "libDoll.dll" exists?
PeDoll done these by pre-copying PE.dll to %windir%
A: For creating, modify monitor's PATH to add current dir
   For attaching, see below

My impl of "doll" command:
	Create: DetourCreateProcessWithDllEx()
		- Mechanism: CreateProcess(CREATE_SUSPENDED) then modify IAT
		- Need libDoll.dll to export at least 1 function (ordinal #1)
		- Need DllMain() to run DetourRestoreAfterWith()
	Create static (not for now): Use Detours binary functions to modify execuable file
		- Similar to "doll iti" and maybe "doll bi"
		- For more see https://github.com/microsoft/Detours/wiki/OverviewPayloads
	Attach: "doll di"
		- Done by: get LoadLibraryW()'s address, copy libDoll *full path* to target memory, then CreateRemoteThread()
		- This works because THREAD_START_ROUTINE's stack layout is exactly the same as LoadLibraryW's.
		  DWORD (WINAPI *)(LPVOID) vs HMODULE (WINAPI *)(LPCWSTR)

