If the target is to make a user-friendly Windows API monitor, there are tons of ready-to-use tools lying around:
	Huorong Sword: https://www.huorong.cn/
	API Monitor: https://www.rohitab.com/apimonitor
	Process Monitor from Sysinternals: https://docs.microsoft.com/en-us/sysinternals/downloads/procmon
So my version of PEDoll will NOT focus on pretty-printing Windows APIs, but on better interoperability with internal procedures

----------

Hook Events:
	Before...
		return context-related data
		Approve/Reject(req. SPOffset & AX)/Terminate/Prompt
	After...
		return context-related data
		Continue/Terminate/Prompt

*IMPORTANT*: The "binary hooker" PeDoll implements ALSO only work on procedures
		And only support 1 instance

registers to preserve:
	x86
		pushad/popad
		eax, ecx, edx, ebx, esp, ebp, esi, edi
	x64
		rax, rcx, rdx, rbx, rbp, rsp, rdi, rsi, r8, r9
	(?) FP registers (sub ebp, 16; movdqu xmmword ptr[ebp], xmm0)
		xmm0, xmm1, xmm2, xmm3

calling conventions:
	x86
		cdecl/stdcall (stack)
		fastcall (rcx, rdx, stack)
	x64
		msvc (rcx, rdx, r8, r9, stack)
		gcc (rdi, rsi, rdx, rcx, r8, r9, stack)

----------

How the commands in original PeDoll are implemented:

- Monitor commands
* doll
	- "iti": IAT rewriting
		- Creating a new execuable with PE.dll in the IAT
	- "bi": OEP rewriting
		- Creating a new execuable with OEP redirected to the LoadLibrary() shellcode
	- "di": Remote thread (recommended for attaching)
		- CreateRemoteThread() with LoadLibrary() as OEP
	- "db": OEP rewriting approach I (recommended for launching)
		- CreateProcess(CREATE_SUSPENDED), then redirect OEP to LoadLibrary() shellcode
	- "ac": OEP rewriting approach II
		- Basically the same as "db"
* shell
	- CreateProcess()
* enumprocess
	- CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS)
* ls
	- FindFirstFile()
* kill
	- Get process handle by CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS), then TerminateProcess()

- Doll commands
* hook
	- A big switch() comparing against a known API list
	- See DLLMain_cn.cpp!HookFunctionCommand
* unhook
	- rt
* terminate
	- exit(0)
* run
	- Did nothing but reply a ACK packet
* esp
	- ACK packet with *current* esp value
	- Is of any use?
* readMemory
	- ReadProcessMemory() with GetCurrentProcess()
* binary
	- Activate the spare APIHooker
	- Locate mechanism: Search binary from GetModuleHandle(NULL) to (0x07ffffff - size) step 1
* unbinary
	- rt

----------

lexer replacement(?): https://github.com/skeeto/optparse
https://github.com/xamarin/XamarinComponents/tree/master/XPlat/Mono.Options

https://github.com/OmarAflak/Asynchronous-Socket-Class-C-Windows/blob/master/src/SocketServer.cpp
https://docs.microsoft.com/zh-cn/dotnet/api/system.net.sockets.tcplistener?view=netframework-4.8

----------

TPuppetOEPFromBinary(): // TODO: Boyer-Moore algorithm?

NOTE: From https://docs.microsoft.com/en-us/windows-hardware/drivers/gettingstarted/virtual-address-spaces :
> For a 32-bit process, the virtual address space is usually the 2-gigabyte range 0x00000000 through 0x7FFFFFFF. For a 64-bit process, the virtual address space is the 8-terabyte range 0x000'00000000 through 0x7FF'FFFFFFFF.
> In 32-bit Windows, the total available virtual address space is 2^32 bytes (4 gigabytes). Usually the lower 2 gigabytes are used for user space, and the upper 2 gigabytes are used for system space.
> In 64-bit Windows, the theoretical amount of virtual address space is 2^64 bytes (16 exabytes), but only a small portion of the 16-exabyte range is actually used. The 8-terabyte range from 0x000'00000000 through 0x7FF'FFFFFFFF is used for user space, and portions of the 248-terabyte range from 0xFFFF0800'00000000 through 0xFFFFFFFF'FFFFFFFF are used for system space.
i.e. Searching directly to the end is no longer an option. So how to do?

(???) Even CheatEngine Uses per-byte method
http://www.ruanyifeng.com/blog/2013/05/boyer-moore_string_search_algorithm.html
https://social.msdn.microsoft.com/forums/en-US/65c1ab16-2690-4117-9d3c-aa55f5cbc453/searching-binary-data#778f3f7e-17f3-48dc-8a47-c1678cfc33c8

C implemention at Wikipedia is a good choice:
https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_string-search_algorithm#Implementations

Before start searching, use Win32 API to enum all readable + execuable regions, any only perform search in them
Both improve speed and avoiding segfaults
https://docs.microsoft.com/zh-cn/windows/win32/api/memoryapi/nf-memoryapi-virtualquery
https://docs.microsoft.com/zh-cn/windows/win32/api/winnt/ns-winnt-memory_basic_information
Only perform search when ((State & MEM_COMMIT) && !(Protect & PAGE_NOACCESS) && (Protect & (PAGE_EXECUTE_READ | PAGE_EXECUTE_READWRITE | PAGE_EXECUTE_WRITECOPY)))
PAGE_EXECUTE is not allowed (searching involves reading)

For a written algorithm:
https://stackoverflow.com/a/4035387

----------

ARGHHHH C# Interop

Recv packet routine:
	receive sizeof(UInt32) bytes (block at here)
	convert this byte[] into UInt32 as $size (UInt32 System.BitConverter.ToUInt32(byte[] value, int startIndex))
	receive ($size - sizeof(UInt32)) bytes
	combine two byte[]s as $buffer
	Puppet.Util.Deserialize<PACKET>(buffer) as $packet
	OnRecv(packet, buffer)
	(In OnRecv) Puppet.Util.Deserialize(<PACKET_*>|String|Binary)(buffer) as it wish

Send packet routine (not STRING or BINARY):
	new Puppet.PACKET_*() as $packet
	Puppet.Util.Serialize<PACKET_*> as $buffer
	send buffer

Send packet routine (STRING or BINARY):
	Puppet.Util.Serialize(String|Binary)() as $buffer
	send buffer

