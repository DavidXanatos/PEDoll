If the target is to make a user-friendly Windows API monitor, there are tons of ready-to-use tools lying around:
	Huorong Sword: https://www.huorong.cn/
	API Monitor: https://www.rohitab.com/apimonitor
	Process Monitor from Sysinternals: https://docs.microsoft.com/en-us/sysinternals/downloads/procmon
So my version of PEDoll will NOT focus on pretty-printing Windows APIs, but on better interoperability with internal procedures

----------

Hook Events:
	Before...
		return context-related data
		Approve/Reject(req. SPOffset & AX)/Terminate/Prompt
	After...
		return context-related data
		Continue/Terminate/Prompt

NOTE: The "binary hooker" PeDoll implements ALSO only work on procedures
		And only support 1 instance

registers to preserve:
	x86
		pushad/popad
		eax, ecx, edx, ebx, esp, ebp, esi, edi
	x64
		rax, rcx, rdx, rbx, rbp, rsp, rdi, rsi, r8, r9
	(?) FP registers (sub ebp, 16; movdqu xmmword ptr[ebp], xmm0)
		xmm0, xmm1, xmm2, xmm3

calling conventions:
	x86
		cdecl/stdcall (stack)
		fastcall (rcx, rdx, stack)
	x64
		msvc (rcx, rdx, r8, r9, stack)
		gcc (rdi, rsi, rdx, rcx, r8, r9, stack)

*IMPORTANT*: Also save/load EFLAGS|RFLAGS with (PUSHFD/POPFD)|(PUSHFQ|POPFQ)?

----------

How the commands in original PeDoll are implemented:

- Monitor commands
* doll
	- "iti": IAT rewriting
		- Creating a new execuable with PE.dll in the IAT
	- "bi": OEP rewriting
		- Creating a new execuable with OEP redirected to the LoadLibrary() shellcode
	- "di": Remote thread (recommended for attaching)
		- CreateRemoteThread() with LoadLibrary() as OEP
	- "db": OEP rewriting approach I (recommended for launching)
		- CreateProcess(CREATE_SUSPENDED), then redirect OEP to LoadLibrary() shellcode
	- "ac": OEP rewriting approach II
		- Basically the same as "db"
* shell
	- CreateProcess()
* enumprocess
	- CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS)
* ls
	- FindFirstFile()
* kill
	- Get process handle by CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS), then TerminateProcess()

- Doll commands
* hook
	- A big switch() comparing against a known API list
	- See DLLMain_cn.cpp!HookFunctionCommand
* unhook
	- rt
* terminate
	- exit(0)
* run
	- Did nothing but reply a ACK packet
* esp
	- ACK packet with *current* esp value
	- Is of any use?
* readMemory
	- ReadProcessMemory() with GetCurrentProcess()
* binary
	- Activate the spare APIHooker
	- Locate mechanism: Search binary from GetModuleHandle(NULL) to (0x07ffffff - size) step 1
* unbinary
	- rt

----------

https://github.com/xamarin/XamarinComponents/tree/master/XPlat/Mono.Options
Detailed information: https://github.com/mono/mono/blob/master/mcs/class/Mono.Options/Mono.Options/Options.cs#L40
custom separator: { "--dump=,", (x, y) => ... }
default parameters: { "<>", x => ... }

----------

ARGHHHH C# Interop

Recv packet routine:
	receive sizeof(UInt32) bytes (block at here)
	convert this byte[] into UInt32 as $size (UInt32 System.BitConverter.ToUInt32(byte[] value, int startIndex))
	receive ($size - sizeof(UInt32)) bytes
	combine two byte[]s as $buffer
	Puppet.Util.Deserialize<PACKET>(buffer) as $packet
	OnRecv(packet, buffer)
	(In OnRecv) Puppet.Util.Deserialize(<PACKET_*>|String|Binary)(buffer) as it wish
		Still need a PuppetExpect<>

Send packet routine (not STRING or BINARY):
	new Puppet.PACKET_*() as $packet
	Puppet.Util.Serialize<PACKET_*> as $buffer
	send buffer

Send packet routine (STRING or BINARY):
	Puppet.Util.Serialize(String|Binary)() as $buffer
	send buffer

----------

C# has "lock(obj) { ...}"
a "nothing-but-a-lock" object: "object theLock = new object();"

Shift-Enter inputs newline in the Visual Studio resource editor

Set Form.Localizable to True
Change Language to write in values

cmdline to search for untranslated strings (// TODO: "...")
grep -r --include=*.cs "// TODO: \"" | sed 's/.*TODO: //g' | sort | uniq

----------

Threads/Tasks of PEDollController:

(Main thread):
	initialize
	start CmdEngine and GUI
	wait until CmdEngine ends
	finalize

CmdEngine:
	initialize readline providers
	wait for a line
	OnCommand(cmd, isGUI)
		may start Listener or stop CmdEngine
	loop forever

Listener: // Listeners?
	bind to TCP port
	wait for incoming connection
	create & start a new Client
	loop forever

Client:
	wait for incoming packet
	OnRecv(packet, buffer)
		may stop current Client (put in a DEAD status, not removing from the list)
	loop forever

GUI:
	show FSplash
		initialize GUI-related things
	show FMain
	wait until FMain closes

----------

Examples of command `hook`:

# (x64) Hooks WinExec(), print the command it trys to execute, then reject it
hook WinExec --before --echo="lpCmdLine = {str(arg(0))}" --verdict=reject

# (x86) Binary example (pattern from original PeDoll)
hook *8B5424048B4C240885D2750D --convention=cdecl --stack=0,0 --before --echo="str1 = {str(poi(sp+4+4))}" --echo="str2 = {str(poi(sp+4+8))}" --verdict=reject

# (x86) Reject WriteFile() (shows the usage of context dictionary)
hook CreateFileA --before --verdict=approve --after --ctx="hFile_{ax}","{str(arg(1))}" --verdict=approve
hook CreateFileW --before --verdict=approve --after --ctx="hFile_{ax}","{wstr(arg(1))}" --verdict=approve
hook WriteFile --convention=stdcall --stack=20,1 --before --echo="File: {ctx(\"hFile_\"+ax.ToString())}" --dump={arg(1)},{arg(2)} --verdict=reject

# (x64) Dump all send() and recv() data (shows the usage of "after" hooks)
hook ws2_32!send --before --dump={arg(1)},{(int)arg(2)} --verdict=approve
hook ws2_32!recv --before --verdict=approve --after --dump={arg(1)},{(int)ax} --verdict=approve

----------

.NET Framework v4.7.2 is preinstalled starting from Windows 10 v1803, and is installable starting from Windows 7 SP1.

C#'s `using` is like Python's `import` PLUS C++'s `using`/`typedef`
https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/using-directive

using Model = System.ComponentModel; <=> import System.ComponentModel as Model
using word = System.UInt32; <=> typedef uint32_t word;

C#'s `using static` <=> Python's `from ... import *`
https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/using-static

using static System.Math; <=> from System.Math import *

Extensions to `eval` expressions:

word (uword):
	Plan A: Alias to Int32/Int64 based on target's bitness
	Plan B: Alias to Int64 (match to Puppet.PACKET_INTEGER)
	PlanC: (Above plans does not seem to work) just use ulong and do not provide these things

str() (wstr()):
	(I've forgot to put a string-reading operation into libPuppet)
	Read sizeof(byte)/sizeof(char) bytes at a time, starting from given address,
	until read byte/char is zero, or a read error occurred (libDoll did check on this)
	Convert byte[] into string with Encoding.Default.GetString()/Encoding.Unicode.GetString()

ctx():
	Read context dictionary

poi():
	Read sizeof(uword) bytes from given address, fail if read error occurred
	Convert byte[] into uword with BitConverter.ToUInt32()/BitConverter.ToUInt64()

arg():
	Return expression based on the convention
	For stack arguments, like "poi(sp + 4 + 4 * INDEX)"

ax, bx, ...:
	Fields with only getters, sends Puppet.PACKET_CONTEXT

